# This file was generated by "rake generate_rbs"
module Rollbar
  class Notification
    # _@param_ `config_file`
    def initialize: (String config_file) -> void

    def to_s: () -> String

    def to_tf: () -> String

    # @!attribute [r] conditions
    #  @return [Array<Condition::Base, Condition::Rate>]
    # @!attribute [r] configs
    #  @return [Array<Hash{String => Object}>]
    class Rule
      # _@param_ `conditions`
      def self.never_met?: (::Array[(Condition::Base | Condition::Rate)] conditions) -> bool

      # _@param_ `rule`
      def initialize: (::Hash[String, ::Array[Object]] rule) -> void

      # _@param_ `original`
      def initialize_dup: (Rule original) -> void

      # _@param_ `other`
      def ==: (Object other) -> bool

      def remove_redundant_conditions!: () -> Rule

      def never_met?: () -> bool

      # _@param_ `old_condition`
      # 
      # _@param_ `new_condition`
      def replace_condition!: (Condition::Base old_condition, Condition::Base new_condition) -> Rule

      def lowest_target_level: () -> Integer

      def lowest_target_level_value: () -> String

      # Splits rules if necessary.
      # Assuming the following two rules:
      #   level = critical, title contains substring "bar"
      #   level >= error,   title contains substring "baz"
      # the second rule will be split into two rules with "eq" operation:
      #   level = critical, title contains substring "bar"
      #   level = critical, title contains substring "baz"
      #   level = error,    title contains substring "baz"
      # whereas assuming the following two rules:
      #   level = warning, title contains substring "bar"
      #   level >= error,   title contains substring "baz"
      # this method doesn't split the second rule because each rule
      # is already mutually exclusive.
      # 
      # _@param_ `highest_lowest_target_level` â€” the highest lowest_target_level among the preceding rules.
      def split_rules: (Integer highest_lowest_target_level) -> ::Array[Rule]

      # _@param_ `new_conditions`
      def add_conditions!: ((Condition::Base | ::Array[Condition::Base]) new_conditions) -> Rule

      def build_additional_conditions_set_for_subsequent_rules: () -> ::Hash[String, ::Array[::Array[Condition::Base]]]

      def level_condition: () -> Condition::Level?

      attr_reader conditions: ::Array[(Condition::Base | Condition::Rate)]

      attr_reader configs: ::Array[::Hash[String, Object]]
    end

    class Channel
      CHANNEL_TO_TEXT: ::Hash[String, String]

      # _@param_ `channel`
      # 
      # _@param_ `triggers`
      # 
      # _@param_ `variables`
      def initialize: (String channel, ::Hash[String, ::Array[::Hash[String, Object]]] triggers, ::Hash[String, String] variables) -> void

      def to_s: () -> String

      # _@param_ `provider`
      # 
      # _@param_ `namespace`
      def to_tf: (String? provider, String? namespace) -> String
    end

    class Trigger
      TRIGGER_TO_TEXT: ::Hash[String, String]
      TEXT_TEMPLATE: ERB
      TF_TEMPLATE: ERB

      # _@param_ `channel`
      # 
      # _@param_ `name`
      # 
      # _@param_ `rules`
      # 
      # _@param_ `variables`
      def initialize: (
                        String channel,
                        String name,
                        ::Array[::Hash[String, Object]] rules,
                        ::Hash[String, String] variables
                      ) -> void

      def to_s: () -> String

      # _@param_ `provider`
      # 
      # _@param_ `namespace`
      def to_tf: (String? provider, String? namespace) -> String

      def build_mutually_exclusive_rules: () -> ::Array[Rule]
    end

    module Condition
      # @!attribute [r] type
      #  @return [String]
      # @!attribute [r] operation
      #  @return [String]
      # @!attribute [r] value
      #  @return [String]
      class Base
        # _@param_ `operation`
        # 
        # _@param_ `value`
        def initialize: (String operation, String value) -> void

        # _@param_ `other`
        def ==: (Object other) -> bool

        def hash: () -> Integer

        def to_tf: () -> String

        # _@param_ `other`
        def redundant_to?: ((Base | Rate) other) -> bool

        attr_reader type: String

        attr_reader operation: String

        attr_reader value: String
      end

      # @!attribute [r] path
      #  @return [String]
      class Path < Rollbar::Notification::Condition::Base
        SUPPORTED_OPERATIONS: ::Array[String]
        OPERATION_TO_TEXT: ::Hash[String, String]

        # _@param_ `path`
        # 
        # _@param_ `operation`
        # 
        # _@param_ `value`
        def initialize: (String path, String operation, String value) -> void

        # _@param_ `other`
        def ==: (Object other) -> bool

        def hash: () -> Integer

        def to_tf: () -> String

        def to_s: () -> String

        def build_complement_condition: () -> Path

        # _@param_ `other`
        def redundant_to?: ((Base | Rate) other) -> bool

        attr_reader path: String
      end

      # @!attribute [r] type
      #  @return [String]
      class Rate
        PERIOD_TO_TEXT: ::Hash[Integer, String]

        # _@param_ `count`
        # 
        # _@param_ `period`
        def initialize: (Integer count, Integer period) -> void

        def to_s: () -> String

        def to_tf: () -> String

        # _@param_ `other`
        def redundant_to?: ((Base | Rate) other) -> bool

        attr_reader type: String
      end

      # @!attribute [r] level
      #  @return [Integer]
      class Level < Rollbar::Notification::Condition::Base
        SUPPORTED_OPERATIONS: ::Array[String]
        SUPPORTED_VALUES: ::Array[String]

        # _@param_ `lowest_target_level`
        def self.build_eq_conditions_from: (Integer lowest_target_level) -> ::Array[Level]

        # _@param_ `operation`
        # 
        # _@param_ `value`
        def initialize: (String operation, String value) -> void

        def to_s: () -> String

        def target_level_values: () -> ::Array[String]

        attr_reader level: Integer
      end

      class Title < Rollbar::Notification::Condition::Base
        SUPPORTED_OPERATIONS: ::Array[String]
        OPERATION_TO_TEXT: ::Hash[String, String]

        def initialize: (String operation, String value) -> void

        def to_s: () -> String

        def build_complement_condition: () -> Title
      end

      class Framework < Rollbar::Notification::Condition::Base
        SUPPORTED_OPERATIONS: ::Array[String]

        def initialize: (String operation, String value) -> void

        def to_s: () -> String
      end

      class Environment < Rollbar::Notification::Condition::Base
        SUPPORTED_OPERATIONS: ::Array[String]

        def initialize: (String operation, String value) -> void

        def to_s: () -> String

        def build_complement_condition: () -> Environment
      end
    end
  end
end